{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/ts/main.ts","webpack:///./src/ts/piano-keys.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","customElements","PianoKeys","tag","define","PianoKeysLayout","PianoKeysMode","HTMLElement","super","_whiteKeyBounds","Map","_blackKeyBounds","_keys","_hoveredKey","this","_shadowRoot","attachShadow","_canvas","document","createElement","classList","add","_ctx","getContext","style","textContent","CSS_STYLE","append","ResizeObserver","resize","observe","addEventListener","event","handleMouseDown","handleMouseUp","handleMouseMove","handleMouseLeave","keyNumber","includes","getNumberAttribute","newValue","setAttribute","getStringAttribute","draw","start","end","whiteKey","whiteKeyHover","whiteKeyOn","blackKey","blackKeyHover","blackKeyOn","stroke","clear","layout","linear","drawLinear","width","height","drawClassic","keyBounds","fillStyle","getFillStyle","fillRect","x","y","isBlackKey","Math","round","mouseX","offsetX","mouseY","offsetY","keyPressed","getKeyAtPosition","filter","v","notifyKeyChange","newHoveredKey","dispatchEvent","CustomEvent","changed","buttons","length","result","Array","from","entries","some","entry","bounds","boundingClientRect","getBoundingClientRect","startKey","endKey","max","range","keyWidth","fixed","MIN_KEY_WIDTH","ceil","currentStep","currentKey","floor","drawKey","set","whiteKeyWidth","numWhiteKeys","blackKeyHeight","blackKeyWidth","whiteKeyCounter","nextWhiteX","first","e","hasAttribute","getAttribute","Number"],"mappings":"aACE,IAAIA,EAAmB,GAGvB,SAASC,EAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUC,QAGnC,IAAIC,EAASJ,EAAiBE,GAAY,CACzCG,EAAGH,EACHI,GAAG,EACHH,QAAS,IAUV,OANAI,EAAQL,GAAUM,KAAKJ,EAAOD,QAASC,EAAQA,EAAOD,QAASF,GAG/DG,EAAOE,GAAI,EAGJF,EAAOD,QAKfF,EAAoBQ,EAAIF,EAGxBN,EAAoBS,EAAIV,EAGxBC,EAAoBU,EAAI,SAASR,EAASS,EAAMC,GAC3CZ,EAAoBa,EAAEX,EAASS,IAClCG,OAAOC,eAAeb,EAASS,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhEZ,EAAoBkB,EAAI,SAAShB,GACX,oBAAXiB,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAeb,EAASiB,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAeb,EAAS,aAAc,CAAEmB,OAAO,KAQvDrB,EAAoBsB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQrB,EAAoBqB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFA1B,EAAoBkB,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOrB,EAAoBU,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRzB,EAAoB6B,EAAI,SAAS1B,GAChC,IAAIS,EAAST,GAAUA,EAAOqB,WAC7B,WAAwB,OAAOrB,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAH,EAAoBU,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRZ,EAAoBa,EAAI,SAASiB,EAAQC,GAAY,OAAOjB,OAAOkB,UAAUC,eAAe1B,KAAKuB,EAAQC,IAGzG/B,EAAoBkC,EAAI,SAIjBlC,EAAoBA,EAAoBmC,EAAI,G,gFClFrD,aAEyC,MAArCC,eAAenB,IAAI,EAAAoB,UAAUC,MAC/BF,eAAeG,OAAO,EAAAF,UAAUC,IAAK,EAAAD,Y,6BCKvC,IAAYG,E,iDAAZ,SAAYA,GACV,oBACA,kBAFF,CAAYA,EAAA,EAAAA,kBAAA,EAAAA,gBAAe,KAQ3B,SAAYC,GACV,kBACA,gBACA,oBACA,cAJF,CAAY,EAAAA,gBAAA,EAAAA,cAAa,KAyBzB,MAAaJ,UAAkBK,YAY7B,cACEC,QANM,KAAAC,gBAA0C,IAAIC,IAC9C,KAAAC,gBAA0C,IAAID,IAC9C,KAAAE,MAAkB,GAClB,KAAAC,YAAsB,KAI5BC,KAAKC,YAAcD,KAAKE,aAAa,CAAC5B,KAAM,WAE5C0B,KAAKG,QAAUC,SAASC,cAAc,UACtCL,KAAKG,QAAQG,UAAUC,IAAI,yBAE3BP,KAAKQ,KAAOR,KAAKG,QAAQM,WAAW,MAEpC,MAAMC,EAAQN,SAASC,cAAc,SACrCK,EAAMC,YAAcC,EAEpBZ,KAAKC,YAAYY,OAAOH,GACxBV,KAAKC,YAAYY,OAAOb,KAAKG,SAGN,IAAIW,eAAe,IAAMd,KAAKe,UACtCC,QAAQhB,MAEvBA,KAAKG,QAAQc,iBAAiB,YAAcC,GAAUlB,KAAKmB,gBAAgBD,IAC3Ed,SAASa,iBAAiB,UAAW,IAAMjB,KAAKoB,iBAChDpB,KAAKG,QAAQc,iBAAiB,YAAcC,GAAUlB,KAAKqB,gBAAgBH,IAC3ElB,KAAKG,QAAQc,iBAAiB,aAAc,IAAMjB,KAAKsB,oBAMlD,iBACL,MAAO,aAMF,gCACL,MAAO,CACL,QACA,MACA,SACA,QACA,OACA,SACA,WACA,gBACA,aACA,WACA,gBACA,cASG,kBAAkBC,GACvB,MAAO,CAAC,EAAG,EAAG,EAAG,EAAG,IAAIC,SAASD,EAAY,IAS/C,WACE,OAAOvB,KAAKF,MAQd,YACE,OAAOE,KAAKyB,mBAAmB,SAGjC,UAAiBC,GACf1B,KAAK2B,aAAa,QAAS,GAAKD,GASlC,UACE,OAAO1B,KAAKyB,mBAAmB,OAGjC,QAAeC,GACb1B,KAAK2B,aAAa,MAAO,GAAKD,GAWhC,YACE,OAAO1B,KAAKyB,mBAAmB,SAGjC,UAAiBC,GACf1B,KAAK2B,aAAa,QAAS,GAAKD,GASlC,aACE,OAAO1B,KAAK4B,mBAAmB,UAGjC,WAAkBF,GAChB1B,KAAK2B,aAAa,SAAUD,GAY9B,WACE,OAAO1B,KAAK4B,mBAAmB,QAGjC,SAAgBF,GACV1B,KAAK1B,OAASoD,IAChB1B,KAAK2B,aAAa,OAAQD,GAC1B1B,KAAKF,MAAQ,GACbE,KAAKD,YAAc,KACnBC,KAAK6B,QAOT,iBACE,OAAO7B,KAAKD,YAUd,aACE,OAAOC,KAAK4B,mBAAmB,UAQjC,eACE,OAAO5B,KAAK4B,mBAAmB,YAQjC,oBACE,OAAO5B,KAAK4B,mBAAmB,iBAQjC,iBACE,OAAO5B,KAAK4B,mBAAmB,cAOjC,eACE,OAAO5B,KAAK4B,mBAAmB,YAQjC,oBACE,OAAO5B,KAAK4B,mBAAmB,iBAQjC,iBACE,OAAO5B,KAAK4B,mBAAmB,cAGjC,WAAkBF,GAChB1B,KAAK2B,aAAa,SAAUD,GAC5B1B,KAAK6B,OAGP,aAAoBH,GAClB1B,KAAK2B,aAAa,WAAYD,GAC9B1B,KAAK6B,OAGP,kBAAyBH,GACvB1B,KAAK2B,aAAa,gBAAiBD,GACnC1B,KAAK6B,OAGP,eAAsBH,GACpB1B,KAAK2B,aAAa,aAAcD,GAChC1B,KAAK6B,OAGP,aAAoBH,GAClB1B,KAAK2B,aAAa,WAAYD,GAC9B1B,KAAK6B,OAGP,kBAAyBH,GACvB1B,KAAK2B,aAAa,gBAAiBD,GACnC1B,KAAK6B,OAGP,eAAsBH,GACpB1B,KAAK2B,aAAa,aAAcD,GAChC1B,KAAK6B,OAMA,oBAEL7B,KAAK8B,MAAQ9B,KAAK8B,OAAyB,GAC3C9B,KAAK+B,IAAM/B,KAAK+B,KAA2B,GAC3C/B,KAAKgC,SAAWhC,KAAKgC,UAAsB,OAC3ChC,KAAKiC,cAAgBjC,KAAKiC,eAAiB,OAC3CjC,KAAKkC,WAAalC,KAAKkC,YAAoB,OAC3ClC,KAAKmC,SAAWnC,KAAKmC,UAAsB,OAC3CnC,KAAKoC,cAAgBpC,KAAKoC,eAAiB,OAC3CpC,KAAKqC,WAAarC,KAAKqC,YAAoB,OAC3CrC,KAAKsC,OAAStC,KAAKsC,QAAwB,OAE3CtC,KAAKe,SAMA,2BACLf,KAAK6B,OAMA,OACL7B,KAAKL,gBAAgB4C,QACrBvC,KAAKH,gBAAgB0C,QAEjBvC,KAAKwC,SAAWjD,EAAgBkD,OAClCzC,KAAK0C,WAAW1C,KAAKG,QAAQwC,MAAO3C,KAAKG,QAAQyC,QAEjD5C,KAAK6C,YAAY7C,KAAKG,QAAQwC,MAAO3C,KAAKG,QAAQyC,QAO5C,QAAQrB,EAAmBuB,GACnC9C,KAAKQ,KAAKuC,UAAY/C,KAAKgD,aAAazB,GACxCvB,KAAKQ,KAAKyC,SAASH,EAAUI,EAAGJ,EAAUK,EAAGL,EAAUH,MAAOG,EAAUF,QAErD,WAAf5C,KAAKwC,QAAuBpD,EAAUgE,WAAW7B,KACnDvB,KAAKQ,KAAKuC,UAAY/C,KAAKsC,OAC3BtC,KAAKQ,KAAKyC,SAASI,KAAKC,MAAMR,EAAUI,GAAIJ,EAAUK,EAAG,EAAGL,EAAUF,QACtE5C,KAAKQ,KAAKyC,SAASI,KAAKC,MAAMR,EAAUI,GAAIJ,EAAUK,EAAIL,EAAUF,OAAS,EAAGE,EAAUH,MAAO,GACjG3C,KAAKQ,KAAKyC,SAASI,KAAKC,MAAMR,EAAUI,EAAIJ,EAAUH,MAAQ,GAAIG,EAAUK,EAAG,EAAGL,EAAUF,SAOtF,aAAarB,GACrB,OAAOnC,EAAUgE,WAAW7B,GACxBvB,KAAKF,MAAM0B,SAASD,GAChBvB,KAAKqC,WAAcrC,KAAKD,cAAgBwB,EACpCvB,KAAKoC,cAAgBpC,KAAKmC,SAClCnC,KAAKF,MAAM0B,SAASD,GAChBvB,KAAKkC,WAAclC,KAAKD,cAAgBwB,EACpCvB,KAAKiC,cAAgBjC,KAAKgC,SAGhC,gBAAgBd,GACtB,MAAM5C,EAAO0B,KAAK1B,KAElB,GAAa,SAATA,EACF,OAGF,MAAMiF,EAASrC,EAAMsC,QACfC,EAASvC,EAAMwC,QAEfC,EAAa3D,KAAK4D,iBAAiBL,EAAQE,GAE/B,MAAdE,IACW,WAATrF,GACE0B,KAAKF,MAAM0B,SAASmC,GACtB3D,KAAKF,MAAQE,KAAKF,MAAM+D,OAAQC,GAAMA,IAAMH,GAE5C3D,KAAKF,MAAQ,IAAIE,KAAKF,MAAO6D,GAG/B3D,KAAK+D,oBAEL/D,KAAKF,MAAQ,CAAC6D,GACd3D,KAAK+D,oBAIT/D,KAAK6B,OAGC,gBACN,MAAMvD,EAAO0B,KAAK1B,KAEL,SAATA,IAIS,WAATA,IACF0B,KAAKF,MAAQ,GACbE,KAAK+D,mBAGP/D,KAAK6B,QAGC,gBAAgBX,GACtB,MAAM5C,EAAO0B,KAAK1B,KAElB,GAAa,SAATA,EACF,OAGF,MAAMiF,EAASrC,EAAMsC,QACfC,EAASvC,EAAMwC,QAEfM,EAAgBhE,KAAK4D,iBAAiBL,EAAQE,GAOpD,GALIzD,KAAKD,aAAeiE,IACtBhE,KAAKD,YAAciE,EACnBhE,KAAKiE,cAAc,IAAIC,YAAY,cAGxB,SAAT5F,EAEF,YADA0B,KAAK6B,OAIP,IAAIsC,GAAU,EAEO,GAAjBjD,EAAMkD,SAAwB,UAAR9F,EACpB0B,KAAKF,MAAMuE,OAAS,IACtBrE,KAAKF,MAAQ,GACbqE,GAAU,GAGC,UAAT7F,IACwB,IAAtB0B,KAAKF,MAAMuE,QAAgBrE,KAAKF,MAAM,KAAOE,KAAKD,cACpDC,KAAKF,MAAQ,CAACE,KAAKD,aACnBoE,GAAU,IAKZA,GACFnE,KAAK+D,kBAGP/D,KAAK6B,OAGC,mBACN7B,KAAKD,YAAc,KACnBC,KAAKiE,cAAc,IAAIC,YAAY,aAEnClE,KAAK6B,OAGC,iBAAiBqB,EAAWC,GAClC,IAAImB,EAAS,KAcb,MAZA,IACKC,MAAMC,KAAKxE,KAAKH,gBAAgB4E,cAChCF,MAAMC,KAAKxE,KAAKL,gBAAgB8E,YACnCC,KAAKC,IACL,MAAMC,EAAoBD,EAAM,GAChC,GAAIzB,GAAK0B,EAAO1B,GAAKA,EAAI0B,EAAO1B,EAAI0B,EAAOjC,OACpCQ,GAAKyB,EAAOzB,GAAKA,EAAIyB,EAAOzB,EAAIyB,EAAOhC,OAE5C,OADA0B,EAASK,EAAM,IACR,IAIJL,EAGD,kBACNtE,KAAKiE,cAAc,IAAIC,YAAY,cAG7B,SACN,MAAMW,EAAqB7E,KAAKG,QAAQ2E,wBACxC9E,KAAKG,QAAQwC,MAAQkC,EAAmBlC,MACxC3C,KAAKG,QAAQyC,OAASiC,EAAmBjC,OACzC5C,KAAK6B,OAGC,WAAWc,EAAeC,GAChC,MAAMmC,EAAW/E,KAAK8B,MAChBkD,EAAS3B,KAAK4B,IAAIjF,KAAK+B,IAAKgD,EAAW,GAE7C,IAAIG,EAAOC,EAEO,MAAdnF,KAAKoF,OAAiBpF,KAAKoF,OAAS,GACtCF,EAAQ,EAAIF,EAASD,EACrBI,EAAWxC,EAAQuC,IAEnBC,EAAW9B,KAAK4B,IAAI7F,EAAUiG,cAAerF,KAAKoF,OAClDF,EAAQ7B,KAAKiC,KAAK3C,EAAQwC,IAG5B,IAAII,EAAc,EAElB,KAAOA,EAAcL,GAAO,CAC1B,MAAMM,EAAaD,EAAcR,EAC3B7B,EAAIG,KAAKoC,MAAMF,EAAcJ,GAEnCnF,KAAK0F,QAAQF,EAAY,CACvBtC,IACAC,EAAG,EACHR,MAAOwC,EACPvC,WAGE2C,EAAc,IAChBvF,KAAKQ,KAAKuC,UAAY/C,KAAKsC,OAC3BtC,KAAKQ,KAAKyC,SAASC,EAAG,EAAG,EAAGN,IAG9B,MAAMgC,EAAoB,CACxB1B,IACAC,EAAG,EACHR,MAAOwC,EACPvC,UAGExD,EAAUgE,WAAWoC,GACvBxF,KAAKH,gBAAgB8F,IAAIH,EAAYZ,GAErC5E,KAAKL,gBAAgBgG,IAAIH,EAAYZ,GAGvCW,KAII,YAAY5C,EAAeC,GACjC,IAAImC,EAAW/E,KAAK8B,MAEhB1C,EAAUgE,WAAW2B,IACvBA,IAGF,IAMIG,EAAOU,EAAeC,EANtBb,EAAS3B,KAAK4B,IAAIjF,KAAK+B,IAAKgD,EAAW,GAEvC3F,EAAUgE,WAAW4B,IACvBA,IAKgB,MAAdhF,KAAKoF,OAAiBpF,KAAKoF,OAAS,GACtCF,EAAQ,EAAIF,EAASD,EACrBc,EAAexC,KAAKC,MAAM4B,GAAS,EAAI,KACvCU,EAAgBjD,EAAQkD,IAExBD,EAAgBvC,KAAK4B,IAAIjF,KAAKoF,MAAOhG,EAAUiG,eAC/CQ,EAAexC,KAAKiC,KAAK3C,EAAQiD,GACjCV,EAAQ7B,KAAKiC,KAAKO,GAAgB,GAAK,KAGzC,MAAMC,EAA0B,IAATlD,EACjBmD,EAAgB1C,KAAKC,MAAsB,IAAhBsC,GACjC,IAAII,EAAkB,EAGtB,IAAK,IAAI7I,EAAI,EAAGA,EAAI+H,IAAS/H,EAAG,CAC9B,MAAMqI,EAAarI,EAAI4H,EAEvB,GAAI3F,EAAUgE,WAAWoC,GAAa,CACpC,MAAMS,EAAaD,EAAkBJ,EAC/B1C,EAAIG,KAAKC,MAAM2C,EAA6B,GAAhBF,GAElC/F,KAAKH,gBAAgB8F,IAAIH,EAAY,CACnCtC,IACAC,EAAG,EACHR,MAAOoD,EACPnD,OAAQkD,QAEL,CACL,MAAM5C,EAAIG,KAAKC,MAAM0C,EAAkBJ,GAEvC5F,KAAKL,gBAAgBgG,IAAIH,EAAY,CACnCtC,IACAC,EAAG,EACHR,MAAOiD,EACPhD,WAGFoD,IAIF,IAAIE,GAAQ,EAEZ,IAAK,MAAMC,KAAK5B,MAAMC,KAAKxE,KAAKL,gBAAgB8E,WAC9CzE,KAAK0F,QAAQS,EAAE,GAAIA,EAAE,IAEjBD,EACFA,GAAQ,GAERlG,KAAKQ,KAAKuC,UAAY/C,KAAKsC,OAC3BtC,KAAKQ,KAAKyC,SAASkD,EAAE,GAAGjD,EAAG,EAAG,EAAGN,IAKrC,IAAK,MAAMuD,KAAK5B,MAAMC,KAAKxE,KAAKH,gBAAgB4E,WAC9CzE,KAAK0F,QAAQS,EAAE,GAAIA,EAAE,KAKnB,mBAAmBzH,GACzB,OAAOsB,KAAKoG,aAAa1H,GAAOsB,KAAKqG,aAAa3H,GAAO,KAGnD,mBAAmBA,GACzB,OAAOsB,KAAKoG,aAAa1H,GAAO4H,OAAOtG,KAAKqG,aAAa3H,IAAQ,MAhlBrE,cAEiB,EAAA2G,cAAwB,EAklBzC,MAAMzE,EAAY","file":"piano-keys.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","import { PianoKeys } from './piano-keys';\r\n\r\nif (customElements.get(PianoKeys.tag) == null) {\r\n  customElements.define(PianoKeys.tag, PianoKeys);\r\n}","declare class ResizeObserver {\r\n  constructor(...args : any[]);\r\n  public observe(...elements: HTMLElement[]): any;\r\n}\r\n\r\n/**\r\n * The layout for the keys. See {@link PianoKeys.layout}.\r\n */\r\nexport enum PianoKeysLayout {\r\n  classic   = 'classic',\r\n  linear    = 'linear',\r\n}\r\n\r\n/**\r\n * The layout for the keys. See {@link PianoKeys.mode}.\r\n */\r\nexport enum PianoKeysMode {\r\n  toggle    = 'toggle',\r\n  slide     = 'slide',\r\n  default   = 'default',\r\n  none      = 'none',\r\n}\r\n\r\n/**\r\n * Describes the position and the size of a key relative to the canvas origin.\r\n */\r\nexport interface KeyBounds {\r\n  x: number;\r\n  y: number;\r\n  width: number;\r\n  height: number;\r\n}\r\n\r\n/**\r\n * A canvas-based piano keyboard.\r\n *\r\n * ```\r\n * <piano-keys min=\"60\" max=\"84\" mode=\"slide\"></piano-keys>\r\n * ```\r\n * @noInheritDoc\r\n */\r\nexport class PianoKeys extends HTMLElement {\r\n\r\n  private static MIN_KEY_WIDTH: number = 5;\r\n\r\n  private _shadowRoot: ShadowRoot;\r\n  private readonly _canvas: HTMLCanvasElement;\r\n  private _ctx: CanvasRenderingContext2D;\r\n  private _whiteKeyBounds: Map<number, KeyBounds> = new Map<number, KeyBounds>();\r\n  private _blackKeyBounds: Map<number, KeyBounds> = new Map<number, KeyBounds>();\r\n  private _keys: number[] = [];\r\n  private _hoveredKey: number = null;\r\n\r\n  constructor() {\r\n    super();\r\n    this._shadowRoot = this.attachShadow({mode: 'closed'});\r\n\r\n    this._canvas = document.createElement('canvas');\r\n    this._canvas.classList.add('piano-keyboard-canvas');\r\n\r\n    this._ctx = this._canvas.getContext('2d');\r\n\r\n    const style = document.createElement('style');\r\n    style.textContent = CSS_STYLE;\r\n\r\n    this._shadowRoot.append(style);\r\n    this._shadowRoot.append(this._canvas);\r\n\r\n    // Events handlers\r\n    const resizeObserver = new ResizeObserver(() => this.resize());\r\n    resizeObserver.observe(this);\r\n\r\n    this._canvas.addEventListener('mousedown', (event) => this.handleMouseDown(event));\r\n    document.addEventListener('mouseup', () => this.handleMouseUp());\r\n    this._canvas.addEventListener('mousemove', (event) => this.handleMouseMove(event));\r\n    this._canvas.addEventListener('mouseleave', () => this.handleMouseLeave());\r\n  }\r\n\r\n  /**\r\n   * HTML tag name used for this element.\r\n   */\r\n  public static get tag(): string {\r\n    return \"piano-keys\";\r\n  }\r\n\r\n  /**\r\n   * Observed HTML attributes (custom element implementation).\r\n   */\r\n  public static get observedAttributes(): string[] {\r\n    return [\r\n      'start',\r\n      'end',\r\n      'layout',\r\n      'fixed',\r\n      'mode',\r\n      'stroke',\r\n      'whiteKey',\r\n      'whiteKeyHover',\r\n      'whiteKeyOn',\r\n      'blackKey',\r\n      'blackKeyHover',\r\n      'blackKeyOn',\r\n    ]; \r\n  }\r\n\r\n  /**\r\n   * Does the provided key value correspond to a black key ?\r\n   * @remark This method will always return false for negative values.\r\n   * @param keyNumber the value to test. A key number of 0 corresponds to a `C-2` note.\r\n   */\r\n  public static isBlackKey(keyNumber: number): boolean {\r\n    return [1, 3, 6, 8, 10].includes(keyNumber % 12);\r\n  }\r\n\r\n  /**\r\n   * An array of keys that are currently pressed.\r\n   *\r\n   * @remark this returns the actual array used internally to render the keys. You shouldn't mutate it yourself unless you\r\n   * know what you're doing in order to avoid weird mouse logic behaviours. Altering the array won't trigger a redraw.\r\n   */\r\n  public get keys(): number[] {\r\n    return this._keys;\r\n  }\r\n\r\n  // Attributes/properties reflection\r\n\r\n  /**\r\n   * First key value to show.\r\n   */\r\n  public get start(): number {\r\n    return this.getNumberAttribute('start');\r\n  }\r\n\r\n  public set start(newValue: number) {\r\n    this.setAttribute('start', '' + newValue);\r\n  }\r\n\r\n  /**\r\n   * Last key value to show.\r\n   *\r\n   * @remark When `fixed` is set to a strictly positive number, the `end` value is ignored. See {@link fixed}.\r\n   * @remark The computed range that is actually shown is restricted to be at least `2`.\r\n   */\r\n  public get end(): number {\r\n    return this.getNumberAttribute('end');\r\n  }\r\n\r\n  public set end(newValue: number) {\r\n    this.setAttribute('end', '' + newValue);\r\n  }\r\n\r\n  /**\r\n   * A fixed pixel size for a key.\r\n   *\r\n   * If `layout` is set to `linear` then it is the width of any key. If `layout` is set to `classic` then it is the width\r\n   * of a white key.\r\n   * @remark when `fixed` is set to a strictly positive value, the `end` parameter is ignored and the keyboard won't adapt\r\n   * the size of the keys when it is externally resized. It will instead draw as many keys as possible in the available space\r\n   */\r\n  public get fixed(): number {\r\n    return this.getNumberAttribute('fixed');\r\n  }\r\n\r\n  public set fixed(newValue: number) {\r\n    this.setAttribute('fixed', '' + newValue);\r\n  }\r\n\r\n  /**\r\n   * The keys layout, either `classic` or `linear`. Defaults to `classic`.\r\n   *\r\n   * In `linear` mode, each key has the same width. In `classic` mode, the white keys are placed at regular interval and\r\n   * the black keys are shorter, just like in a real-life classical piano.\r\n   */\r\n  public get layout(): PianoKeysLayout | string {\r\n    return this.getStringAttribute('layout');\r\n  }\r\n\r\n  public set layout(newValue: string) {\r\n    this.setAttribute('layout', newValue);\r\n  }\r\n\r\n  /**\r\n   * The mouse interaction mode either `default`, `slide`, `toggle` or `none`.\r\n   *\r\n   * In `default` mode, a mouse press activates a key until the the mouse button is released. Mouse drags are ignored.\r\n   * In `slide` mode, mouse drags also activate keys. Only one key stays activate at the same time.\r\n   * In `toggle` mode, a mouse press toggles the state of a key.\r\n   * In `none` mode, keys events are ignored. The hovered key doesn't get styled and pressing keys won't do anything.\r\n   * @remark Previously pressed keys are lost when changing the mode.\r\n   */\r\n  public get mode(): PianoKeysMode | string {\r\n    return this.getStringAttribute('mode');\r\n  }\r\n\r\n  public set mode(newValue: string) {\r\n    if (this.mode !== newValue) {\r\n      this.setAttribute('mode', newValue);\r\n      this._keys = [];\r\n      this._hoveredKey = null;\r\n      this.draw();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The key value that is currently under the mouse, or null if there isn't.\r\n   */\r\n  public get hoveredKey(): number {\r\n    return this._hoveredKey;\r\n  }\r\n\r\n  // Colors attributes/properties reflection\r\n\r\n  /**\r\n   * Fill style used for strokes.\r\n   *\r\n   * It can be either a color, a gradient or a pattern as defined in the Canvas API.\r\n   */\r\n  public get stroke(): string {\r\n    return this.getStringAttribute('stroke');\r\n  }\r\n\r\n  /**\r\n   * Fill style used for white keys in normal state.\r\n   *\r\n   * It can be either a color, a gradient or a pattern as defined in the Canvas API.\r\n   */\r\n  public get whiteKey(): string {\r\n    return this.getStringAttribute('whiteKey');\r\n  }\r\n\r\n  /**\r\n   * Fill style used for white keys when hovered.\r\n   *\r\n   * It can be either a color, a gradient or a pattern as defined in the Canvas API.\r\n   */\r\n  public get whiteKeyHover(): string {\r\n    return this.getStringAttribute('whiteKeyHover');\r\n  }\r\n\r\n  /**\r\n   * Fill style used for white keys when pressed.\r\n   *\r\n   * It can be either a color, a gradient or a pattern as defined in the Canvas API.\r\n   */\r\n  public get whiteKeyOn(): string {\r\n    return this.getStringAttribute('whiteKeyOn');\r\n  }\r\n  /**\r\n   * Fill style used for black keys in normal state.\r\n   *\r\n   * It can be either a color, a gradient or a pattern as defined in the Canvas API.\r\n   */\r\n  public get blackKey(): string {\r\n    return this.getStringAttribute('blackKey');\r\n  }\r\n\r\n  /**\r\n   * Fill style used for black keys when hovered.\r\n   *\r\n   * It can be either a color, a gradient or a pattern as defined in the Canvas API.\r\n   */\r\n  public get blackKeyHover(): string {\r\n    return this.getStringAttribute('blackKeyHover');\r\n  }\r\n\r\n  /**\r\n   * Fill style used for black keys when hovered.\r\n   *\r\n   * It can be either a color, a gradient or a pattern as defined in the Canvas API.\r\n   */\r\n  public get blackKeyOn(): string {\r\n    return this.getStringAttribute('blackKeyOn');\r\n  }\r\n\r\n  public set stroke(newValue: string) {\r\n    this.setAttribute('stroke', newValue);\r\n    this.draw();\r\n  }\r\n\r\n  public set whiteKey(newValue: string) {\r\n    this.setAttribute('whiteKey', newValue);\r\n    this.draw();\r\n  }\r\n\r\n  public set whiteKeyHover(newValue: string) {\r\n    this.setAttribute('whiteKeyHover', newValue);\r\n    this.draw();\r\n  }\r\n\r\n  public set whiteKeyOn(newValue: string) {\r\n    this.setAttribute('whiteKeyOn', newValue);\r\n    this.draw();\r\n  }\r\n\r\n  public set blackKey(newValue: string) {\r\n    this.setAttribute('blackKey', newValue);\r\n    this.draw();\r\n  }\r\n\r\n  public set blackKeyHover(newValue: string) {\r\n    this.setAttribute('blackKeyHover', newValue);\r\n    this.draw();\r\n  }\r\n\r\n  public set blackKeyOn(newValue: string) {\r\n    this.setAttribute('blackKeyOn', newValue);\r\n    this.draw();\r\n  }\r\n\r\n  /**\r\n   * Called when the HTML node is first connected to the DOM (custom element implementation).\r\n   */\r\n  public connectedCallback(): void {\r\n    // Default colors\r\n    this.start = this.start                 || 60;\r\n    this.end = this.end                     || 84;\r\n    this.whiteKey = this.whiteKey           || '#fff';\r\n    this.whiteKeyHover = this.whiteKeyHover || '#eee';\r\n    this.whiteKeyOn = this.whiteKeyOn       || '#ccc';\r\n    this.blackKey = this.blackKey           || '#888';\r\n    this.blackKeyHover = this.blackKeyHover || '#333';\r\n    this.blackKeyOn = this.blackKeyOn       || '#111';\r\n    this.stroke = this.stroke               || '#000';\r\n\r\n    this.resize();\r\n  }\r\n\r\n  /**\r\n   * Called whenever an observed HTML attribute changes (custom element implementation). Redraws the component.\r\n   */\r\n  public attributeChangedCallback(/* name, oldValue, newValue */): void {\r\n    this.draw();\r\n  }\r\n\r\n  /**\r\n   * Draws the keys.\r\n   */\r\n  public draw(): void {\r\n    this._whiteKeyBounds.clear();\r\n    this._blackKeyBounds.clear();\r\n\r\n    if (this.layout === PianoKeysLayout.linear) {\r\n      this.drawLinear(this._canvas.width, this._canvas.height);\r\n    } else {\r\n      this.drawClassic(this._canvas.width, this._canvas.height);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Draws a single key. This method can be redefined\r\n   */\r\n  protected drawKey(keyNumber: number, keyBounds: KeyBounds): void {\r\n    this._ctx.fillStyle = this.getFillStyle(keyNumber);\r\n    this._ctx.fillRect(keyBounds.x, keyBounds.y, keyBounds.width, keyBounds.height);\r\n\r\n    if (this.layout == 'classic' && PianoKeys.isBlackKey(keyNumber)) {\r\n      this._ctx.fillStyle = this.stroke;\r\n      this._ctx.fillRect(Math.round(keyBounds.x), keyBounds.y, 1, keyBounds.height);\r\n      this._ctx.fillRect(Math.round(keyBounds.x), keyBounds.y + keyBounds.height - 1, keyBounds.width, 1);\r\n      this._ctx.fillRect(Math.round(keyBounds.x + keyBounds.width - 1), keyBounds.y, 1, keyBounds.height);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the fill style to use based on the state of the provided key.\r\n   */\r\n  protected getFillStyle(keyNumber: number): string {\r\n    return PianoKeys.isBlackKey(keyNumber) ?\r\n        this._keys.includes(keyNumber) ?\r\n            this.blackKeyOn : (this._hoveredKey === keyNumber ?\r\n                this.blackKeyHover : this.blackKey) :\r\n        this._keys.includes(keyNumber) ?\r\n            this.whiteKeyOn : (this._hoveredKey === keyNumber ?\r\n                this.whiteKeyHover : this.whiteKey)\r\n  }\r\n\r\n  private handleMouseDown(event: MouseEvent): void {\r\n    const mode = this.mode;\r\n\r\n    if (mode === 'none') {\r\n      return;\r\n    }\r\n\r\n    const mouseX = event.offsetX;\r\n    const mouseY = event.offsetY;\r\n\r\n    const keyPressed = this.getKeyAtPosition(mouseX, mouseY);\r\n\r\n    if (keyPressed != null) {\r\n      if (mode === 'toggle') {\r\n        if (this._keys.includes(keyPressed)) {\r\n          this._keys = this._keys.filter((v) => v !== keyPressed);\r\n        } else {\r\n          this._keys = [...this._keys, keyPressed];\r\n        }\r\n\r\n        this.notifyKeyChange();\r\n      } else {\r\n        this._keys = [keyPressed];\r\n        this.notifyKeyChange();\r\n      }\r\n    }\r\n\r\n    this.draw();\r\n  }\r\n\r\n  private handleMouseUp(/* event: MouseEvent */): void {\r\n    const mode = this.mode;\r\n\r\n    if (mode === 'none') {\r\n      return;\r\n    }\r\n\r\n    if (mode !== 'toggle') {\r\n      this._keys = [];\r\n      this.notifyKeyChange();\r\n    }\r\n\r\n    this.draw();\r\n  }\r\n\r\n  private handleMouseMove(event: MouseEvent): void {\r\n    const mode = this.mode;\r\n\r\n    if (mode === 'none') {\r\n      return;\r\n    }\r\n\r\n    const mouseX = event.offsetX;\r\n    const mouseY = event.offsetY;\r\n\r\n    const newHoveredKey = this.getKeyAtPosition(mouseX, mouseY);\r\n\r\n    if (this._hoveredKey != newHoveredKey) {\r\n      this._hoveredKey = newHoveredKey;\r\n      this.dispatchEvent(new CustomEvent('keyhover'));\r\n    }\r\n\r\n    if (mode === 'none') {\r\n      this.draw();\r\n      return;\r\n    }\r\n\r\n    let changed = false;\r\n\r\n    if (event.buttons == 0 && mode != 'toggle') {\r\n      if (this._keys.length > 0) {\r\n        this._keys = [];\r\n        changed = true;\r\n      }\r\n    } else {\r\n      if (mode === 'slide') {\r\n        if (this._keys.length !== 1 || this._keys[0] !== this._hoveredKey) {\r\n          this._keys = [this._hoveredKey];\r\n          changed = true;          \r\n        }\r\n      }\r\n    }\r\n\r\n    if (changed) {\r\n      this.notifyKeyChange();\r\n    }\r\n\r\n    this.draw();\r\n  }\r\n\r\n  private handleMouseLeave(/* event: MouseEvent */): void {\r\n    this._hoveredKey = null;\r\n    this.dispatchEvent(new CustomEvent('keyhover'));\r\n    \r\n    this.draw();\r\n  }\r\n\r\n  private getKeyAtPosition(x: number, y: number): number {\r\n    let result = null;\r\n\r\n    [\r\n      ...Array.from(this._blackKeyBounds.entries()),\r\n      ...Array.from(this._whiteKeyBounds.entries()),\r\n    ].some(entry => {\r\n      const bounds: KeyBounds = entry[1];\r\n      if (x >= bounds.x && x < bounds.x + bounds.width\r\n          && y >= bounds.y && y < bounds.y + bounds.height) {\r\n        result = entry[0];\r\n        return true;\r\n      }\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  private notifyKeyChange(): void {\r\n    this.dispatchEvent(new CustomEvent('keychange'));\r\n  }\r\n\r\n  private resize(): void {\r\n    const boundingClientRect = this._canvas.getBoundingClientRect();\r\n    this._canvas.width = boundingClientRect.width;\r\n    this._canvas.height = boundingClientRect.height;\r\n    this.draw();\r\n  }\r\n\r\n  private drawLinear(width: number, height: number): void {\r\n    const startKey = this.start;\r\n    const endKey = Math.max(this.end, startKey + 2);\r\n\r\n    let range, keyWidth;\r\n\r\n    if (this.fixed == null || this.fixed <= 0) {\r\n      range = 1 + endKey - startKey;\r\n      keyWidth = width / range;\r\n    } else {\r\n      keyWidth = Math.max(PianoKeys.MIN_KEY_WIDTH, this.fixed);\r\n      range = Math.ceil(width / keyWidth);\r\n    }\r\n\r\n    let currentStep = 0;\r\n\r\n    while (currentStep < range) {\r\n      const currentKey = currentStep + startKey;\r\n      const x = Math.floor(currentStep * keyWidth);\r\n\r\n      this.drawKey(currentKey, {\r\n        x,\r\n        y: 0,\r\n        width: keyWidth, \r\n        height,\r\n      });\r\n      \r\n      if (currentStep > 0) {\r\n        this._ctx.fillStyle = this.stroke;\r\n        this._ctx.fillRect(x, 0, 1, height);\r\n      }\r\n\r\n      const bounds: KeyBounds = {\r\n        x,\r\n        y: 0, \r\n        width: keyWidth,\r\n        height,\r\n      };\r\n\r\n      if (PianoKeys.isBlackKey(currentKey)) {\r\n        this._blackKeyBounds.set(currentKey, bounds);\r\n      } else {\r\n        this._whiteKeyBounds.set(currentKey, bounds);\r\n      }\r\n\r\n      currentStep++;\r\n    }\r\n  }\r\n\r\n  private drawClassic(width: number, height: number): void {\r\n    let startKey = this.start;\r\n\r\n    if (PianoKeys.isBlackKey(startKey)) {\r\n      startKey--;\r\n    }\r\n\r\n    let endKey = Math.max(this.end, startKey + 2);\r\n\r\n    if (PianoKeys.isBlackKey(endKey)) {\r\n      endKey++;\r\n    }\r\n\r\n    let range, whiteKeyWidth, numWhiteKeys;\r\n\r\n    if (this.fixed == null || this.fixed <= 0) {\r\n      range = 1 + endKey - startKey;\r\n      numWhiteKeys = Math.round(range * (7 / 12));\r\n      whiteKeyWidth = width / numWhiteKeys;\r\n    } else {\r\n      whiteKeyWidth = Math.max(this.fixed, PianoKeys.MIN_KEY_WIDTH);\r\n      numWhiteKeys = Math.ceil(width / whiteKeyWidth);\r\n      range = Math.ceil(numWhiteKeys * (12 / 7));\r\n    }\r\n\r\n    const blackKeyHeight = height * 0.65;\r\n    const blackKeyWidth = Math.round(whiteKeyWidth * 0.58);\r\n    let whiteKeyCounter = 0;\r\n\r\n    // Determine key bounds\r\n    for (let i = 0; i < range; ++i) {\r\n      const currentKey = i + startKey;\r\n\r\n      if (PianoKeys.isBlackKey(currentKey)) {\r\n        const nextWhiteX = whiteKeyCounter * whiteKeyWidth;\r\n        const x = Math.round(nextWhiteX - blackKeyWidth * 0.5);\r\n        \r\n        this._blackKeyBounds.set(currentKey, {\r\n          x,\r\n          y: 0, \r\n          width: blackKeyWidth,\r\n          height: blackKeyHeight,\r\n        });\r\n      } else {\r\n        const x = Math.round(whiteKeyCounter * whiteKeyWidth);\r\n\r\n        this._whiteKeyBounds.set(currentKey, {\r\n          x,\r\n          y: 0, \r\n          width: whiteKeyWidth,\r\n          height,\r\n        });\r\n\r\n        whiteKeyCounter++;\r\n      }\r\n\r\n      // Draw white keys\r\n      let first = true;\r\n\r\n      for (const e of Array.from(this._whiteKeyBounds.entries())) {\r\n        this.drawKey(e[0], e[1]);\r\n\r\n        if (first) {\r\n          first = false;\r\n        } else {\r\n          this._ctx.fillStyle = this.stroke;\r\n          this._ctx.fillRect(e[1].x, 0, 1, height);\r\n        }\r\n      }\r\n\r\n      // Draw black keys\r\n      for (const e of Array.from(this._blackKeyBounds.entries())) {\r\n        this.drawKey(e[0], e[1]);\r\n      }\r\n    }\r\n  }\r\n\r\n  private getStringAttribute(key: string): string {\r\n    return this.hasAttribute(key) ? this.getAttribute(key) : null;\r\n  }\r\n\r\n  private getNumberAttribute(key: string): number {\r\n    return this.hasAttribute(key) ? Number(this.getAttribute(key)) : null;\r\n  }\r\n}\r\n\r\nconst CSS_STYLE = `\r\n:host {\r\n  display: block;\r\n}\r\n\r\n.piano-keyboard-canvas {\r\n  width: 100%;\r\n  height: 100%;\r\n}\r\n`;"],"sourceRoot":""}